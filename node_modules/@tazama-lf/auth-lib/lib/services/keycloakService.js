"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeycloakService = void 0;
const tslib_1 = require("tslib");
const jsonwebtoken_1 = tslib_1.__importDefault(require("jsonwebtoken"));
const iAuthConfig_1 = require("../interfaces/iAuthConfig");
const jwtService_1 = require("./jwtService");
class KeycloakService {
    realm;
    baseUrl;
    constructor() {
        this.realm = iAuthConfig_1.authConfig.keycloakRealm;
        this.baseUrl = iAuthConfig_1.authConfig.authURL;
    }
    /**
     * Authenticates with the provided username and password via KeyCloak to get a KeyCloak token
     * Generates a TazamaToken from the KeyCloak Token with added claims
     *
     * @param {string} username - The username for authentication.
     * @param {string} password - The password for authentication.
     * @returns {Promise<string>} - A promise that resolves to a signed JWT token.
    */
    async getToken(username, password) {
        const form = new URLSearchParams();
        form.append('client_id', iAuthConfig_1.authConfig.clientID);
        form.append('client_secret', iAuthConfig_1.authConfig.clientSecret);
        form.append('username', username);
        form.append('password', password);
        form.append('grant_type', 'password');
        const myHeaders = new Headers();
        myHeaders.append('Content-Type', 'application/x-www-form-urlencoded');
        const res = await fetch(`${this.baseUrl}/realms/${this.realm}/protocol/openid-connect/token`, {
            method: 'POST',
            body: form,
            headers: myHeaders,
            redirect: 'follow',
        });
        const resBody = JSON.parse(await res.text());
        const token = {
            accessToken: resBody.access_token,
            tokenType: resBody.token_type,
            refreshToken: resBody.refresh_token,
        };
        return (0, jwtService_1.signToken)(await this.generateTazamaToken(token));
    }
    /**
     * Decodes the given Keycloak authentication token and maps out the associated claims.
     *
     * @param {KeycloakAuthToken} authToken - The Keycloak authentication token to decode.
     * @returns {Promise<TazamaToken>} - A promise that resolves to a TazamaToken object containing the mapped claims.
    */
    async generateTazamaToken(authToken) {
        const decodedToken = jsonwebtoken_1.default.decode(authToken.accessToken);
        if (!decodedToken || typeof decodedToken === 'string') {
            throw new Error(`Token is in the wrong format, received ${typeof decodedToken}`);
        }
        if (!decodedToken.sub || !decodedToken.iss || !decodedToken.exp) {
            throw new Error(`Token is missing required properties: sub: ${decodedToken.sub}, iss: ${decodedToken.iss}, exp: ${decodedToken.exp}`);
        }
        return {
            clientId: decodedToken.sub,
            iss: decodedToken.iss,
            sid: decodedToken.sid,
            exp: decodedToken.exp,
            tokenString: authToken.accessToken,
            claims: this.mapTazamaRoles(decodedToken),
        };
    }
    /**
     * Extracts and maps the claims from the decoded Keycloak JWT token.
     *
     * @param {KeycloakJwtToken} decodedToken - The decoded JWT token from Keycloak.
     * @returns {string[]} - An array of privileges extracted from the decoded token.
    */
    mapTazamaRoles(decodedToken) {
        const roles = [];
        for (const res in decodedToken.resource_access) {
            for (const role of decodedToken.resource_access[res].roles) {
                roles.push(role);
            }
        }
        if (decodedToken.realm_access) {
            for (const role of decodedToken.realm_access.roles) {
                roles.push(role);
            }
        }
        return roles;
    }
}
exports.KeycloakService = KeycloakService;
//# sourceMappingURL=keycloakService.js.map