"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signToken = signToken;
exports.verifyToken = verifyToken;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const jsonwebtoken_1 = tslib_1.__importStar(require("jsonwebtoken"));
const iAuthConfig_1 = require("../interfaces/iAuthConfig");
/**
 * Signs the token using a private PEM file (RS256).
 *
 * @param {Token} token - The token to be signed.
 * @returns {string} - The signed JWT token.
*/
function signToken(token) {
    let privateKey;
    try {
        privateKey = fs_1.default.readFileSync(iAuthConfig_1.authConfig.certPathPrivate);
    }
    catch (error) {
        throw new Error('Missing or Corrupted Private Key');
    }
    const signedToken = jsonwebtoken_1.default.sign(token, privateKey, {
        algorithm: 'RS256',
    });
    return signedToken;
}
/**
 * Verifies the JWT token using a public PEM file.
 *
 * @param {string} signedToken - The signed JWT token to be verified.
 * @returns {string | jwt.JwtPayload | undefined} - The decoded payload if verification is successful, otherwise undefined.
*/
function verifyToken(signedToken) {
    const publicKey = fs_1.default.readFileSync(iAuthConfig_1.authConfig.certPathPublic);
    try {
        const verifyRes = jsonwebtoken_1.default.verify(signedToken, publicKey);
        return verifyRes;
    }
    catch (error) {
        if (error instanceof jsonwebtoken_1.TokenExpiredError) {
            throw new Error('401 Unauthorized - token expired');
        }
        else {
            const err = error;
            throw new Error(`401 Unauthorized - ${err.message}`);
        }
    }
}
//# sourceMappingURL=jwtService.js.map